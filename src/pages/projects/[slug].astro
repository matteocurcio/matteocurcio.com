---
import { getCollection } from "astro:content";
import BaseLayout from "../../layouts/BaseLayout.astro";
import { LEGACY_BY_SLUG, LEGACY_REELS, NON_COMPARE_WORK_SLUGS, getLegacyItem } from "../../data/legacyPortfolio";
import { WORK_TECHNICAL_CAPTIONS, fallbackTechnicalCaption } from "../../data/workTechnicalCaptions";
import { REEL_CAPTIONS } from "../../data/reelCaptions";
import wpProjectContent from "../../data/wpProjectContent.json";

const WP_WORK_BASE = "https://matteocurcio.com/work";

type WpContentMap = Record<string, { paragraphs?: string[]; embedUrl?: string; images?: string[] }>;
const wpContent = wpProjectContent as WpContentMap;
const LEGACY_REEL_SLUGS = new Set(LEGACY_REELS.map((item) => item.slug));

const REEL_LAYOUT_OVERRIDES: Record<
  string,
  {
    hideGallery?: boolean;
    sliderGallery?: boolean;
    showClients?: boolean;
    showTools?: boolean;
    showKeywords?: boolean;
    keywordsLabel?: string;
    clientsLabel?: string;
    panelOrder?: Array<"clients" | "tools" | "keywords">;
  }
> = {
  ar: { hideGallery: true },
  immersive: { clientsLabel: "DEPLOYMENTS" },
  mapping: {
    hideGallery: true,
    showClients: false,
    showTools: false,
    showKeywords: true,
    keywordsLabel: "Skills",
    panelOrder: ["keywords", "clients", "tools"]
  },
  finishing: {
    sliderGallery: true,
    showClients: false,
    showTools: true,
    showKeywords: true,
    keywordsLabel: "Skills",
    panelOrder: ["tools", "keywords", "clients"]
  },
  "beauty-retouch": {
    sliderGallery: true,
    showKeywords: false,
    panelOrder: ["clients", "tools", "keywords"]
  },
  advertising: {
    hideGallery: true,
    showTools: false,
    showKeywords: false,
    showClients: true,
    panelOrder: ["clients", "tools", "keywords"]
  }
};

const CREDIT_LABELS = new Set([
  "production",
  "producers",
  "producer",
  "co-producers",
  "co producers",
  "director",
  "directors",
  "dop",
  "camera",
  "hairs",
  "hair",
  "makeup",
  "editors",
  "editor",
  "colorist",
  "colourist",
  "color",
  "vfx",
  "agency",
  "agency producer",
  "client",
  "campaign",
  "project",
  "cinematographer",
  "cinematography",
  "writer",
  "line producer",
  "executive producer",
  "creative director",
  "creative",
  "interactive",
  "script supervisor",
  "ac",
  "post supervisor",
  "assistant director",
  "art director",
  "assistant art",
  "lighting asst",
  "sound",
  "animation",
  "titles",
  "music",
  "featuring",
  "production design",
  "5.1 sound mix",
  "sound mix",
  "finishing"
]);

const CREDIT_COMPOUND_LABELS: Record<string, string[]> = {
  "director & writer": ["Director", "Writer"],
  "color & finishing": ["Color", "Finishing"],
  "color and finishing": ["Color", "Finishing"],
  "color, vfx": ["Color", "VFX"],
  "vfx, color": ["VFX", "Color"]
};

const CREDIT_CANONICAL: Record<string, string> = {
  "co-producers": "Co-producers",
  "co producers": "Co-producers",
  "dop": "DOP",
  "vfx": "VFX",
  "5.1 sound mix": "5.1 Sound Mix",
  "lighting asst": "Lighting Asst.",
  "creative director": "Creative Director",
  "creative": "Creative",
  "script supervisor": "Script Supervisor",
  "ac": "AC",
  "post supervisor": "Post Supervisor",
  "line producer": "Line Producer",
  "executive producer": "Executive Producer",
  "assistant director": "Assistant Director",
  "art director": "Art Director",
  "assistant art": "Assistant Art",
  "agency producer": "Agency Producer",
  "production design": "Production Design"
};

function cleanExcerpt(input?: string) {
  if (!input) return "";
  if (input.includes("(function") || input.includes("$(document")) return "";
  return input
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&#8217;/g, "'")
    .replace(/&#038;/g, "&")
    .replace(/<[^>]+>/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function isEmbedUrl(url?: string) {
  if (!url) return false;
  return /youtube\.com|youtu\.be|vimeo\.com/i.test(url);
}

function normalizeCreditLabel(input: string) {
  return input
    .toLowerCase()
    .replace(/[“”"']/g, "")
    .replace(/\s+/g, " ")
    .replace(/[.:]/g, "")
    .trim();
}

function formatCreditLabel(label: string) {
  const normalized = normalizeCreditLabel(label);
  if (CREDIT_CANONICAL[normalized]) return CREDIT_CANONICAL[normalized];
  return normalized
    .split(" ")
    .map((part) => (part ? part[0].toUpperCase() + part.slice(1) : part))
    .join(" ");
}

function extractCreditLabels(line: string) {
  const normalized = normalizeCreditLabel(line);
  if (!normalized) return [];

  if (CREDIT_COMPOUND_LABELS[normalized]) {
    return CREDIT_COMPOUND_LABELS[normalized];
  }

  if (CREDIT_LABELS.has(normalized)) {
    return [formatCreditLabel(normalized)];
  }

  const splitParts = normalized
    .split(/,|\s+&\s+|\s+and\s+|\s*\/\s*|\s*\+\s*/)
    .map((part) => part.trim())
    .filter(Boolean);

  if (splitParts.length > 1 && splitParts.every((part) => CREDIT_LABELS.has(part))) {
    return splitParts.map((part) => formatCreditLabel(part));
  }

  return [];
}

function splitDescriptionAndCredits(paragraphs: string[]) {
  const intro: string[] = [];
  const credits = new Map<string, string[]>();
  const creditOrder: string[] = [];

  const pushCredit = (label: string, value: string) => {
    const clean = value.replace(/^[-•\s]+/, "").trim();
    if (!clean) return;
    if (!credits.has(label)) {
      credits.set(label, []);
      creditOrder.push(label);
    }
    credits.get(label)?.push(clean);
  };

  for (const paragraph of paragraphs) {
    const lines = paragraph
      .split("\n")
      .map((line) => line.trim())
      .filter(Boolean);

    if (lines.length === 0) continue;

    let currentLabels: string[] = [];
    let sawCreditLabel = false;
    const paragraphIntro: string[] = [];

    for (const line of lines) {
      const labels = extractCreditLabels(line);
      if (labels.length > 0) {
        currentLabels = labels;
        sawCreditLabel = true;
        for (const label of currentLabels) {
          if (!credits.has(label)) {
            credits.set(label, []);
            creditOrder.push(label);
          }
        }
        continue;
      }

      if (currentLabels.length > 0) {
        for (const label of currentLabels) {
          pushCredit(label, line);
        }
      } else {
        paragraphIntro.push(line);
      }
    }

    if (paragraphIntro.length > 0) {
      intro.push(paragraphIntro.join(" "));
    } else if (!sawCreditLabel) {
      intro.push(paragraph);
    }
  }

  const creditList = creditOrder.map((label) => ({
    label,
    values: Array.from(new Set((credits.get(label) || []).filter(Boolean)))
  }));

  return {
    intro: intro.filter(Boolean),
    credits: creditList.filter((item) => item.values.length > 0)
  };
}

function buildBeforeAfterPairs(images: string[], fallbackImage?: string) {
  const befores = new Map<string, string>();
  const afters = new Map<string, string>();
  const extras: string[] = [];

  const keyFor = (src: string) =>
    src
      .replace(/flat|before|raw|log|grade|after|final|look/gi, "")
      .replace(/[-_]+/g, "-")
      .toLowerCase();

  for (const src of images) {
    if (/flat|before|raw|log/i.test(src)) {
      befores.set(keyFor(src), src);
      continue;
    }

    if (/grade|after|final|look/i.test(src)) {
      afters.set(keyFor(src), src);
      continue;
    }

    extras.push(src);
  }

  const pairs: Array<{ before: string; after: string }> = [];

  for (const [key, before] of befores.entries()) {
    const after = afters.get(key);
    if (after) {
      pairs.push({ before, after });
      afters.delete(key);
    } else {
      extras.push(before);
    }
  }

  for (const [, leftoverAfter] of afters.entries()) {
    extras.push(leftoverAfter);
  }

  if (pairs.length === 0 && images.length >= 2) {
    for (let i = 0; i + 1 < images.length; i += 2) {
      pairs.push({ before: images[i], after: images[i + 1] });
    }
    return { pairs, extras: [] as string[] };
  }

  if (pairs.length === 0 && fallbackImage) {
    pairs.push({ before: fallbackImage, after: fallbackImage });
    return { pairs, extras: [] as string[] };
  }

  // Convert any remaining stills into compare frames to keep work pages consistent.
  if (extras.length > 1) {
    const leftover = extras.splice(0, extras.length);
    for (let i = 0; i + 1 < leftover.length; i += 2) {
      pairs.push({ before: leftover[i], after: leftover[i + 1] });
    }
    if (leftover.length % 2 === 1) {
      const last = leftover[leftover.length - 1];
      pairs.push({ before: last, after: last });
    }
  }

  return { pairs, extras };
}

function isReelRoleLabel(value: string) {
  const normalized = normalizeCreditLabel(value);
  return [
    "production",
    "producer",
    "producers",
    "director",
    "dop",
    "camera",
    "editor",
    "editors",
    "vfx",
    "color",
    "colorist",
    "colourist"
  ].includes(normalized);
}

function buildReelWorkItemsFromParagraphs(paragraphs: string[]) {
  const likelySkillTerms = [
    "keynote",
    "powerpoint",
    "final cut",
    "premiere",
    "davinci",
    "cinema 4d",
    "blender",
    "photoshop",
    "illustrator",
    "excel",
    "google sheets",
    "branding",
    "data visualization",
    "motion graphics",
    "interaction design",
    "print design",
    "workshops",
    "skills",
    "ethical standards",
    "data protection"
  ];

  const looksLikeSkillsList = (lines: string[]) => {
    if (lines.length === 0) return false;
    const hitCount = lines.filter((line) => {
      const normalized = line.toLowerCase();
      return likelySkillTerms.some((term) => normalized.includes(term));
    }).length;
    return hitCount / lines.length >= 0.35;
  };

  const lists = paragraphs
    .map((paragraph) =>
      paragraph
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean)
    )
    .filter((lines) => lines.length >= 3);

  for (let i = 0; i + 1 < lists.length; i += 1) {
    const clients = lists[i];
    const projects = lists[i + 1];
    const pairCount = Math.min(clients.length, projects.length);

    if (pairCount < 3) continue;
    if (looksLikeSkillsList(clients) || looksLikeSkillsList(projects)) continue;

    return Array.from({ length: pairCount }, (_, idx) => ({
      title: projects[idx],
      client: clients[idx]
    })).filter((item) => !isReelRoleLabel(item.client));
  }

  return [] as Array<{ title: string; client: string }>;
}

function buildReelWorkItems(credits: Array<{ label: string; values: string[] }>) {
  const getValues = (labelNames: string[]) =>
    credits
      .filter((item) => labelNames.includes(normalizeCreditLabel(item.label)))
      .flatMap((item) => item.values)
      .map((value) => value.trim())
      .filter(Boolean);

  const projectValues = getValues(["project", "campaign"]);
  const clientValues = getValues(["client"]);

  if (projectValues.length === 0 || clientValues.length === 0) return [];

  const len = Math.max(projectValues.length, clientValues.length);
  const items: Array<{ title: string; client: string }> = [];

  for (let i = 0; i < len; i += 1) {
    const title = projectValues[i] || projectValues[projectValues.length - 1];
    const client = clientValues[i] || clientValues[clientValues.length - 1];
    if (!title || !client) continue;
    items.push({ title, client });
  }

  return items.filter((item) => !isReelRoleLabel(item.client));
}

function uniqueStrings(values: string[]) {
  const seen = new Set<string>();
  const out: string[] = [];
  for (const value of values) {
    const clean = value.trim();
    if (!clean) continue;
    const key = clean.toLowerCase();
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(clean);
  }
  return out;
}

function stripReelDuplicateLines(
  paragraphs: string[],
  taxonomyLists: string[][],
  reelItems: Array<{ title: string; client: string }>
) {
  const normalize = (value: string) => value.toLowerCase().replace(/\s+/g, " ").trim();
  const duplicates = new Set<string>(
    [...taxonomyLists.flat(), ...reelItems.flatMap((item) => [item.title, item.client])]
      .map(normalize)
      .filter(Boolean)
  );

  const cleaned = paragraphs
    .map((paragraph) =>
      paragraph
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => {
          const key = normalize(line);
          return key && !duplicates.has(key);
        })
        .join(" ")
        .trim()
    )
    .filter(Boolean);

  return cleaned.length > 0 ? cleaned : paragraphs;
}

function splitMagazineParagraphs(text: string) {
  const normalizedNewlines = text.replace(/\r\n/g, "\n").trim();
  if (!normalizedNewlines) return [] as string[];

  const explicitParagraphs = normalizedNewlines
    .split(/\n\s*\n+/)
    .map((part) => part.replace(/\s+/g, " ").trim())
    .filter(Boolean);

  if (explicitParagraphs.length > 1) return explicitParagraphs;

  const normalized = normalizedNewlines.replace(/\s+/g, " ").trim();
  const sentences =
    normalized.match(/[^.!?]+[.!?]+(?:["')\]]+)?|[^.!?]+$/g)?.map((part) => part.trim()).filter(Boolean) ||
    [normalized];

  if (sentences.length <= 2) return [normalized];

  const sentenceWordCounts = sentences.map((sentence) => sentence.split(/\s+/).filter(Boolean).length);
  const totalWords = sentenceWordCounts.reduce((sum, count) => sum + count, 0);

  if (totalWords < 42 || sentences.length < 3) return [normalized];

  const minParagraphWords = 18;
  let bestBreak = -1;
  let runningWords = 0;
  let bestScore = Number.POSITIVE_INFINITY;

  for (let index = 0; index < sentenceWordCounts.length - 1; index += 1) {
    runningWords += sentenceWordCounts[index];
    const remainingWords = totalWords - runningWords;
    if (runningWords < minParagraphWords || remainingWords < minParagraphWords) continue;
    const score = Math.abs(runningWords - totalWords / 2);
    if (score < bestScore) {
      bestScore = score;
      bestBreak = index;
    }
  }

  if (bestBreak === -1) return [normalized];

  return [
    sentences.slice(0, bestBreak + 1).join(" "),
    sentences.slice(bestBreak + 1).join(" ")
  ];
}

function extractReelTaxonomy(
  paragraphs: string[],
  reelItems: Array<{ title: string; client: string }>
) {
  const toolHints = [
    "keynote",
    "powerpoint",
    "final cut",
    "premiere",
    "davinci",
    "cinema 4d",
    "blender",
    "photoshop",
    "illustrator",
    "excel",
    "google sheets",
    "after effects"
  ];

  const lists = paragraphs
    .map((paragraph) =>
      paragraph
        .split("\n")
        .map((line) => line.trim())
        .filter(Boolean)
    )
    .filter((lines) => lines.length >= 3);

  const toolScore = (lines: string[]) => {
    const hits = lines.filter((line) => {
      const normalized = line.toLowerCase();
      return toolHints.some((hint) => normalized.includes(hint));
    }).length;
    return lines.length === 0 ? 0 : hits / lines.length;
  };

  const nonClientHints = [
    "strategy",
    "design",
    "updates",
    "storytelling",
    "interactivity",
    "experience",
    "transparency",
    "ethical",
    "print",
    "motion",
    "data"
  ];

  const clientScore = (lines: string[]) =>
    lines.reduce((score, line) => {
      const normalized = line.toLowerCase();
      const hasDigits = /\d/.test(line) ? 3 : 0;
      const hasAcronym = /\b[A-Z]{2,}\b/.test(line) ? 2 : 0;
      const hasBrandPunctuation = /[&./]/.test(line) ? 1 : 0;
      const abstractPenalty = nonClientHints.some((hint) => normalized.includes(hint)) ? -2 : 0;
      return score + hasDigits + hasAcronym + hasBrandPunctuation + abstractPenalty;
    }, 0);

  let tools: string[] = [];
  let listsPool = [...lists];

  if (listsPool.length > 0) {
    let bestToolIndex = -1;
    let bestToolScore = 0;
    listsPool.forEach((lines, idx) => {
      const score = toolScore(lines);
      if (score > bestToolScore) {
        bestToolScore = score;
        bestToolIndex = idx;
      }
    });
    if (bestToolIndex >= 0 && bestToolScore >= 0.35) {
      tools = listsPool[bestToolIndex];
      listsPool = listsPool.filter((_, idx) => idx !== bestToolIndex);
    }
  }

  let clients = uniqueStrings(reelItems.map((item) => item.client));
  if (clients.length === 0 && listsPool.length > 0) {
    const brandSignalCount = (lines: string[]) =>
      lines.filter((line) => /\d/.test(line) || /\b[A-Z]{2,}\b/.test(line)).length;

    let bestClientIndex = -1;
    let bestSignalCount = 0;
    listsPool.forEach((lines, idx) => {
      const signal = brandSignalCount(lines);
      if (signal > bestSignalCount) {
        bestSignalCount = signal;
        bestClientIndex = idx;
      }
    });

    if (bestClientIndex >= 0 && bestSignalCount >= 2) {
      clients = listsPool[bestClientIndex] || [];
      listsPool = listsPool.filter((_, idx) => idx !== bestClientIndex);
    } else {
      let fallbackIndex = 0;
      let bestClientScore = -1;
      listsPool.forEach((lines, idx) => {
        const score = clientScore(lines);
        if (score > bestClientScore) {
          bestClientScore = score;
          fallbackIndex = idx;
        }
      });
      clients = listsPool[fallbackIndex] || [];
      listsPool = listsPool.filter((_, idx) => idx !== fallbackIndex);
    }
  }

  let keywords: string[] = [];
  if (listsPool.length > 0) {
    keywords = listsPool[0];
  }
  if (keywords.length === 0) {
    keywords = reelItems.map((item) => item.title);
  }

  return {
    keywords: uniqueStrings(keywords).slice(0, 28),
    tools: uniqueStrings(tools).slice(0, 20),
    clients: uniqueStrings(clients).slice(0, 20)
  };
}

function inferReelClientsLabel(values: string[]) {
  const cleaned = uniqueStrings(values).map((value) => value.trim()).filter(Boolean);
  if (cleaned.length === 0) return "Clients";

  const lowered = cleaned.map((value) => value.toLowerCase());
  const specialtyHints = [
    "skin",
    "hair",
    "teeth",
    "complexion",
    "lighting",
    "smoothing",
    "blemish",
    "removal",
    "correction",
    "enhancement",
    "retouch",
    "detailing",
    "isolation",
    "matching",
    "finishing"
  ];
  const taskHints = [
    "editing",
    "grading",
    "compositing",
    "animation",
    "delivery",
    "version",
    "workflow",
    "management",
    "post",
    "mix"
  ];

  const hasSpecialty = (value: string) => specialtyHints.some((hint) => value.includes(hint));
  const hasTask = (value: string) => taskHints.some((hint) => value.includes(hint));

  const specialtyRatio = lowered.filter(hasSpecialty).length / cleaned.length;
  const taskRatio = lowered.filter(hasTask).length / cleaned.length;

  const nameLike = cleaned.filter((value) => /^[A-Z][A-Za-z'._-]+(?:\s+[A-Z][A-Za-z'._-]+){1,3}$/.test(value) && !/\d/.test(value)).length / cleaned.length;

  if (specialtyRatio >= 0.3) return "Specialties";
  if (taskRatio >= 0.3) return "Tasks";
  if (nameLike >= 0.65) return "Featuring";
  return "Clients";
}
export async function getStaticPaths() {
  const projects = await getCollection("projects");
  const slugs = new Set<string>(projects.map((project) => project.slug));
  Object.keys(LEGACY_BY_SLUG).forEach((slug) => slugs.add(slug));

  return Array.from(slugs).map((slug) => ({ params: { slug } }));
}

const slug = Astro.params.slug ?? "";
const projects = await getCollection("projects");
const project = projects.find((entry) => entry.slug === slug);
const legacy = getLegacyItem(slug);
const migrated = wpContent[slug] || {};

const title = legacy?.title || project?.data.title || slug;
const isNonCompareWork = NON_COMPARE_WORK_SLUGS.has(slug);
const service = LEGACY_REEL_SLUGS.has(slug) ? "REELS" : isNonCompareWork ? "MOTION/PHOTO" : "POST-PRODUCTION";
const client = project?.data.client || "Selected Work";
const year = project?.data.year;
const cover = legacy?.image || project?.data.cover;
const coverAlt = project?.data.coverAlt || title;
const previewVideo =
  legacy?.video ||
  project?.data.previewVideo ||
  (project?.data.videoUrl && /\.(mp4|mov)(\?|#|$)/i.test(project.data.videoUrl) ? project.data.videoUrl : undefined);
const originalUrl = project?.data.originalUrl || `${WP_WORK_BASE}/${slug}`;
const excerpt = cleanExcerpt(project?.data.excerpt);

const embeddedUrl = isEmbedUrl(migrated.embedUrl) ? migrated.embedUrl : undefined;
const videoUrl = embeddedUrl ? undefined : previewVideo;

const descriptionParagraphs =
  (migrated.paragraphs || []).length > 0
    ? (migrated.paragraphs || [])
    : excerpt
      ? [excerpt]
      : [];

const parsed = splitDescriptionAndCredits(descriptionParagraphs);
const isReelPage = LEGACY_REEL_SLUGS.has(slug);
const reelWorkItems = isReelPage
  ? (() => {
      const fromCredits = buildReelWorkItems(parsed.credits);
      if (fromCredits.length > 0) return fromCredits;
      return buildReelWorkItemsFromParagraphs(descriptionParagraphs);
    })()
  : [];
const creditsForDisplayBase = isReelPage
  ? parsed.credits.filter((item) => {
      const normalized = normalizeCreditLabel(item.label);
      return normalized !== "client" && normalized !== "project" && normalized !== "campaign";
    })
  : parsed.credits;

const creditsForDisplay = (() => {
  if (slug !== "drive") return creditsForDisplayBase;

  const ordered = [...creditsForDisplayBase];
  const dopIndex = ordered.findIndex((item) => normalizeCreditLabel(item.label) === "dop");
  const soundIndex = ordered.findIndex((item) => normalizeCreditLabel(item.label) === "sound");

  if (dopIndex < 0 || soundIndex < 0) return ordered;

  const temp = ordered[dopIndex];
  ordered[dopIndex] = ordered[soundIndex];
  ordered[soundIndex] = temp;
  return ordered;
})();
const workCreditsColumnLeft = !isReelPage ? creditsForDisplay.filter((_, index) => index % 2 === 0) : [];
const workCreditsColumnRight = !isReelPage ? creditsForDisplay.filter((_, index) => index % 2 === 1) : [];
const galleryImages = (migrated.images || []).filter((src) => src && src !== cover).slice(0, 16);
const reelOverride = isReelPage ? REEL_LAYOUT_OVERRIDES[slug] || {} : {};
const reelUsesCompare = isReelPage && Boolean(reelOverride.sliderGallery);
const reelHideGallery = isReelPage && Boolean(reelOverride.hideGallery);
const disableBeforeAfter = slug === "spring-party" || isNonCompareWork;
const disableGallery = slug === "spring-party" || reelHideGallery;
const useLightboxGallery = isReelPage || isNonCompareWork;
const gallery = isReelPage
  ? reelUsesCompare
    ? {
        pairs: buildBeforeAfterPairs(galleryImages, undefined).pairs,
        extras: [] as string[]
      }
    : {
        pairs: [] as Array<{ before: string; after: string }>,
        extras: galleryImages.length > 0 ? galleryImages : cover ? [cover] : []
      }
  : disableBeforeAfter
    ? {
        pairs: [] as Array<{ before: string; after: string }>,
        extras: galleryImages.length > 0 ? galleryImages : cover ? [cover] : []
      }
    : buildBeforeAfterPairs(galleryImages, service === "POST-PRODUCTION" ? cover : undefined);

const technicalWorkDescription = !isReelPage
  ? WORK_TECHNICAL_CAPTIONS[slug] || fallbackTechnicalCaption(title, client)
  : undefined;
const technicalWorkParagraphs = technicalWorkDescription
  ? splitMagazineParagraphs(technicalWorkDescription)
  : [];

const reelTaxonomy = isReelPage
  ? extractReelTaxonomy(descriptionParagraphs, reelWorkItems)
  : { keywords: [] as string[], tools: [] as string[], clients: [] as string[] };

const reelKeywords = reelTaxonomy.keywords.length > 0 ? reelTaxonomy.keywords : reelWorkItems.map((item) => item.title);
const reelTools = reelTaxonomy.tools.length > 0 ? reelTaxonomy.tools : ["N/A"];
const reelClients = reelTaxonomy.clients.length > 0 ? reelTaxonomy.clients : reelWorkItems.map((item) => item.client);
const reelShowClients = isReelPage ? reelOverride.showClients !== false : false;
const reelShowTools = isReelPage ? reelOverride.showTools !== false : false;
const reelShowKeywords = false;
const reelKeywordsLabel = isReelPage ? reelOverride.keywordsLabel || "Keywords" : "Keywords";
const reelClientsLabel = isReelPage
  ? reelOverride.clientsLabel || inferReelClientsLabel(reelClients)
  : "Clients";
const reelPanelOrder = (isReelPage ? reelOverride.panelOrder : undefined) || ["clients", "tools", "keywords"];
const reelPanelMap: Record<"clients" | "tools" | "keywords", { label: string; values: string[]; enabled: boolean }> = {
  clients: { label: reelClientsLabel, values: reelClients, enabled: reelShowClients },
  tools: { label: "Tools", values: reelTools, enabled: reelShowTools },
  keywords: { label: reelKeywordsLabel, values: reelKeywords, enabled: reelShowKeywords }
};
const reelPanels = isReelPage
  ? reelPanelOrder
      .map((key) => reelPanelMap[key as "clients" | "tools" | "keywords"])
      .filter((panel) => panel && panel.enabled && panel.values.length > 0)
  : [];
const reelCenterPanel = reelPanels[0];
const reelRightPanels = reelPanels.slice(1);
const reelSidePanels = [
  ...(reelCenterPanel ? [reelCenterPanel] : []),
  ...reelRightPanels
];
const reelDescriptionSeed = isReelPage
  ? stripReelDuplicateLines(parsed.intro, [reelKeywords, reelTools, reelClients], reelWorkItems)
  : [] as string[];
const reelDescriptionParagraphs = isReelPage
  ? (() => {
      const narrative = reelDescriptionSeed.filter((paragraph) => /[.!?]/.test(paragraph) && paragraph.split(/\s+/).length > 14);
      if (narrative.length > 0) return narrative.slice(0, 2);
      return reelDescriptionSeed.slice(0, 1);
    })()
  : [];
const reelNarrativeParagraphs = isReelPage
  ? (REEL_CAPTIONS[slug] || reelDescriptionParagraphs).flatMap((paragraph) => splitMagazineParagraphs(paragraph))
  : [];

const metaText = isReelPage && client === "Selected Work"
  ? year ? String(year) : ""
  : `${client}${year ? ` · ${year}` : ""}`;

const pageTitle = `${title} | Matteo Curcio`;
---

<BaseLayout title={pageTitle} path={isReelPage ? `/reels/${slug}/` : `/projects/${slug}/`} navSection={isReelPage ? "reels" : "works"}>
  <article class="project-layout">
    <header>
      <h1>{title}</h1>
      {metaText && <p class="meta">{metaText}</p>}
    </header>

    {
      embeddedUrl ? (
        <div class="cover project-embed">
          <iframe
            src={embeddedUrl}
            title={`${title} video`}
            loading="lazy"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen
          />
        </div>
      ) : videoUrl ? (
        <div class="cover">
          <video class="project-full-video" src={videoUrl} controls playsinline preload="metadata" />
        </div>
      ) : cover ? (
        <div class="cover">
          <img src={cover} alt={coverAlt} loading="eager" />
        </div>
      ) : null
    }
    {
      isReelPage ? (
        <section class="project-details reel-details">
          <div class="project-description">
            {reelNarrativeParagraphs.length > 0 ? (
              reelNarrativeParagraphs.map((paragraph) => <p>{paragraph}</p>)
            ) : (
              <p>
                Case study snapshot migrated for parity. Full production notes, credits, and legacy formatting are
                available on the original project page.
              </p>
            )}
          </div>

          {
            reelSidePanels.length > 0 && (
              <aside class="project-credits reel-side-stack" aria-label="Reel metadata">
                <section class="reel-meta-grid">
                  {reelSidePanels.map((panel) => (
                    <div class="credit-item">
                      <p class="credit-label">{panel.label}</p>
                      <div class="credit-values-lines">
                        {panel.values.map((value) => (
                          <p class="credit-value-line">{value}</p>
                        ))}
                      </div>
                    </div>
                  ))}
                </section>
              </aside>
            )
          }
        </section>
      ) : (
        <section class={`project-details work-details ${creditsForDisplay.length === 0 ? "single" : ""}`}>
          <div class="project-description">
            {!isReelPage && technicalWorkParagraphs.length > 0 ? (
              technicalWorkParagraphs.map((paragraph) => <p>{paragraph}</p>)
            ) : parsed.intro.length > 0 ? (
              parsed.intro.map((paragraph) => <p>{paragraph}</p>)
            ) : (
              <p>
                Case study snapshot migrated for parity. Full production notes, credits, and legacy formatting are
                available on the original project page.
              </p>
            )}
          </div>

          {
            workCreditsColumnLeft.length > 0 && (
              <aside class="project-credits work-credits-col" aria-label="Project credits column 1">
                <section class="credits-grid">
                  {workCreditsColumnLeft.map((item) => (
                    <div class="credit-item">
                      <p class="credit-label">{item.label}</p>
                      <div class="credit-values-lines">
                        {item.values.map((value) => <p class="credit-value-line">{value}</p>)}
                      </div>
                    </div>
                  ))}
                </section>
              </aside>
            )
          }

          {
            workCreditsColumnRight.length > 0 && (
              <aside class="project-credits work-credits-col" aria-label="Project credits column 2">
                <section class="credits-grid">
                  {workCreditsColumnRight.map((item) => (
                    <div class="credit-item">
                      <p class="credit-label">{item.label}</p>
                      <div class="credit-values-lines">
                        {item.values.map((value) => <p class="credit-value-line">{value}</p>)}
                      </div>
                    </div>
                  ))}
                </section>
              </aside>
            )
          }
        </section>
      )
    }

    {
      ((!isReelPage || reelUsesCompare) && gallery.pairs.length > 0) && (
        <section class="before-after-grid" aria-label="Before and after grade comparisons">
          {gallery.pairs.map((pair, idx) => (
            <figure class="ba-slider" style="--ba-pos:50%">
              <img class="ba-after" src={pair.after} alt={`${title} after`} loading="lazy" />
              <div class="ba-before-wrap">
                <img class="ba-before" src={pair.before} alt={`${title} before`} loading="lazy" />
              </div>
              <div class="ba-handle" aria-hidden="true"></div>
              <input
                class="ba-range"
                type="range"
                min="0"
                max="100"
                value="50"
                aria-label={`Before and after comparison ${idx + 1}`}
              />
            </figure>
          ))}
        </section>
      )
    }

    {
      !disableGallery && gallery.extras.length > 0 && (
        useLightboxGallery ? (
          <>
            <section class="project-gallery reel-gallery" aria-label="Project stills">
              {gallery.extras.map((src, idx) => (
                <button class="reel-lightbox-trigger" type="button" data-lightbox-trigger data-lightbox-index={idx} aria-label="Open frame">
                  <img src={src} alt={title} loading="lazy" />
                </button>
              ))}
            </section>

            <div class="reel-lightbox" data-reel-lightbox hidden aria-hidden="true">
              <button type="button" class="reel-lightbox-nav reel-lightbox-prev" data-lightbox-prev aria-label="Previous frame">←</button>
              <figure class="reel-lightbox-frame">
                <button type="button" class="reel-lightbox-close" data-lightbox-close aria-label="Close frame viewer">×</button>
                <img data-lightbox-image src="" alt="Reel frame preview" />
              </figure>
              <button type="button" class="reel-lightbox-nav reel-lightbox-next" data-lightbox-next aria-label="Next frame">→</button>
            </div>
          </>
        ) : (
          <section class="project-gallery" aria-label="Project stills">
            {gallery.extras.map((src) => (
              <img src={src} alt={title} loading="lazy" />
            ))}
          </section>
        )
      )
    }
  </article>
<script is:inline>
  const sliders = document.querySelectorAll(".ba-slider");
  sliders.forEach((slider) => {
    const range = slider.querySelector(".ba-range");
    if (!range) return;

    const setPos = (value) => {
      const safe = Math.max(0, Math.min(100, value));
      slider.style.setProperty("--ba-pos", `${safe}%`);
      range.value = String(Math.round(safe));
    };

    const setFromClientX = (clientX) => {
      const rect = slider.getBoundingClientRect();
      if (rect.width === 0) return;
      const value = ((clientX - rect.left) / rect.width) * 100;
      setPos(value);
    };

    range.addEventListener("input", () => setPos(Number(range.value)));

    let dragging = false;

    slider.addEventListener("pointerdown", (event) => {
      dragging = true;
      setFromClientX(event.clientX);
      if (slider.setPointerCapture) {
        slider.setPointerCapture(event.pointerId);
      }
    });

    slider.addEventListener("pointermove", (event) => {
      if (!dragging) return;
      setFromClientX(event.clientX);
    });

    const stop = () => {
      dragging = false;
    };

    slider.addEventListener("pointerup", stop);
    slider.addEventListener("pointercancel", stop);
    slider.addEventListener("pointerleave", stop);

    setPos(Number(range.value));
  });

  const details = document.querySelector(".project-details");
  const description = details?.querySelector(".project-description");
  const credits = details?.querySelector(".project-credits");

  if (details && description && credits && !details.classList.contains("single")) {
    const getWordCount = () =>
      (description.textContent || "")
        .trim()
        .split(/\s+/)
        .filter(Boolean).length;

    const fitDescription = () => {
      description.style.removeProperty("--desc-font-size");
      description.style.removeProperty("--desc-line-height");
      description.classList.remove("desc-expanded");

      const words = getWordCount();
      if (words > 70) return;

      const descriptionHeight = description.scrollHeight;
      const creditsHeight = credits.scrollHeight;
      if (!descriptionHeight || creditsHeight <= descriptionHeight + 20) return;

      const ratio = Math.min(1.3, creditsHeight / descriptionHeight);
      const fontSize = Math.min(1.18, Math.max(1.02, Math.pow(ratio, 0.42)));
      const lineHeight = 1.58;

      description.style.setProperty("--desc-font-size", `${fontSize}rem`);
      description.style.setProperty("--desc-line-height", String(lineHeight));
      description.classList.add("desc-expanded");
    };

    fitDescription();
    window.addEventListener("resize", () => requestAnimationFrame(fitDescription));
  }

  const lightbox = document.querySelector("[data-reel-lightbox]");
  if (lightbox) {
    const triggers = Array.from(document.querySelectorAll("[data-lightbox-trigger]"));
    const image = lightbox.querySelector("[data-lightbox-image]");
    const closeBtn = lightbox.querySelector("[data-lightbox-close]");
    const prevBtn = lightbox.querySelector("[data-lightbox-prev]");
    const nextBtn = lightbox.querySelector("[data-lightbox-next]");

    if (image && closeBtn && prevBtn && nextBtn && triggers.length > 0) {
      let activeIndex = 0;

      const render = () => {
        const src = triggers[activeIndex]?.querySelector("img")?.getAttribute("src") || "";
        if (!src) return;
        image.setAttribute("src", src);
      };

      const open = (index) => {
        activeIndex = index;
        render();
        lightbox.hidden = false;
        lightbox.classList.add("is-open");
        lightbox.setAttribute("aria-hidden", "false");
        document.body.classList.add("is-lightbox-open");
      };

      const close = () => {
        lightbox.classList.remove("is-open");
        lightbox.setAttribute("aria-hidden", "true");
        document.body.classList.remove("is-lightbox-open");
        setTimeout(() => {
          lightbox.hidden = true;
          image.setAttribute("src", "");
        }, 180);
      };

      const step = (delta) => {
        activeIndex = (activeIndex + delta + triggers.length) % triggers.length;
        render();
      };

      triggers.forEach((trigger, idx) => {
        trigger.addEventListener("click", () => open(idx));
      });

      closeBtn.addEventListener("click", close);
      prevBtn.addEventListener("click", () => step(-1));
      nextBtn.addEventListener("click", () => step(1));

      lightbox.addEventListener("click", (event) => {
        if (event.target === lightbox) close();
      });

      window.addEventListener("keydown", (event) => {
        if (lightbox.hidden) return;
        if (event.key === "Escape") close();
        if (event.key === "ArrowLeft") step(-1);
        if (event.key === "ArrowRight") step(1);
      });
    }
  }
</script>
</BaseLayout>
